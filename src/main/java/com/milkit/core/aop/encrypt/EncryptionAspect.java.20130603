package com.milkit.core.aop.encrypt;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;

import org.apache.log4j.Logger;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

import com.milkit.core.annotations.encrypt.DoEncryption;
import com.milkit.core.annotations.encrypt.Encrypt;
import com.milkit.core.annotations.encrypt.DoEncryption.EncryptType;
import com.milkit.core.common.AbstractBean;
import com.milkit.core.reflect.ReflectUtil;
import com.milkit.core.security.SecurityUtil;
import com.milkit.core.util.ArrayUtil;


@Aspect 
@Component 
public class EncryptionAspect {
	
    private static final Logger log = Logger.getLogger(EncryptionAspect.class);
    
//    @Autowired
//    private CacheManager cacheManager;
    

//  @Pointcut("execution( * *.encryptField*(..) ) || @annotation(com.milkit.core.annotations.Encrypt)")
//  @Pointcut("execution( * *.encryptField*(..) ) || execution( * *.encryptField*(@com.milkit.core.annotations.Encrypt (*)) )")
//  @Pointcut("execution( * *.encryptField*(..) )")
    @Pointcut("@annotation(com.milkit.core.annotations.encrypt.DoEncryption)")
    public void doEncryption() {}


    @Around("@annotation( doEncryption )")
    public Object encryptionAround(ProceedingJoinPoint joinPoint, DoEncryption doEncryption) throws Throwable {
    	log.debug("encryptBeforeSaving...The method " + joinPoint.getSignature().getName()+ "() begins with " + Arrays.toString(joinPoint.getArgs()));
    	log.debug("encryptBeforeSaving...Target class : "+ joinPoint.getTarget().getClass().getName());
    	
    	Object output = null;
    	
		EncryptType encryptType = doEncryption.type();
			
		if(encryptType == EncryptType.Encrypt) {
	    	Object[] copyArgs = encryptionObject(joinPoint);
	    	output = joinPoint.proceed();
		    	
	    	restoreObject(joinPoint.getArgs(), copyArgs);
		} else if(encryptType == EncryptType.Decrypt) {
			output = decryption( joinPoint.proceed() );
		} else if(encryptType == EncryptType.Both) {
	    	Object[] copyArgs = encryptionObject(joinPoint);
		    	
	    	output = decryption( joinPoint.proceed() );
		    	
	    	restoreObject(joinPoint.getArgs(), copyArgs);
		} else {
			throw new IllegalArgumentException("DoEncryption arguments is not Valid !!["+encryptType+"]");
		}
			
		return output;
     }
    
    
    private Object decryption(Object output) throws Throwable {
    	try {
        	if(output != null){
        		if(output instanceof Collection) {
        			for (@SuppressWarnings("unchecked")
					Iterator<Object> it = ((Collection<Object>) output).iterator(); it.hasNext();) {
        				decryptObject(it.next());
        			}
        		} else if(output instanceof Object[]) {
        			Object[] resultArray = (Object[])output;
        			for (int i=0; i<resultArray.length; i++) {
        				decryptObject(resultArray[i]);
        			}
        		} else {
        			decryptObject(output);
        		}
        	}
        	
        	log.debug("decryptAfterFinding...The method " + output);
            return output;
        } catch (IllegalArgumentException e){
            throw e;
        } 
    	
    }


	private Object[] encryptionObject(ProceedingJoinPoint joinPoint) throws Throwable {
		Object[] args = joinPoint.getArgs();
		Object[] copyArgs = ArrayUtil.getDeepCopyArray(Object.class, args);
		
		if(args != null && args.length > 0) {
//			encryptionMethodArguments(joinPoint, args);

    		encryptObject(args);
    	}

		return copyArgs;
	}
    
	private void encryptionMethodArguments(JoinPoint joinPoint, Object[] args) throws Exception {
		if (joinPoint.getSignature() instanceof MethodSignature) {
			MethodSignature methodSignature = (MethodSignature)joinPoint.getSignature();
			Method method = methodSignature.getMethod();
			
			Class<?>[] paramClasses = method.getParameterTypes();
			Annotation[][] annotations = method.getParameterAnnotations();
				
			for(int j=0; j < annotations.length; j++) {
				for(int k=0; k < annotations[j].length; k++) {
					if(annotations[j][k].annotationType().equals(Encrypt.class) && paramClasses[j].getName().equalsIgnoreCase("java.lang.String")) {
						Method toString = paramClasses[j].getMethod("toString");
						String clearText = (String)toString.invoke((String)args[j], null);
	
						String cipherText = SecurityUtil.encrypt(clearText);
log.debug("clearText:" + clearText);
log.debug("cipherText:" + cipherText);

						ReflectUtil.setStringValue(args[j], cipherText);
					}
				}
	
			}
		}
	}


	private void encryptObject(Object[] args) {
		for(int i=0; i<args.length; i++) {
			Object argObj = args[i];
			if(argObj != null) {
				Class<? extends Object> argClass = argObj.getClass();
				
				try {
					for (Field f : argClass.getDeclaredFields()) {
						if (f.isAnnotationPresent(Encrypt.class) && f.getType().getName().equalsIgnoreCase("java.lang.String")) {
				        	String clearText = (String) ReflectUtil.getFieldValue(args[i], f.getName());
							String cipherText = SecurityUtil.encrypt(clearText);
							
log.debug("clearText:" + clearText);
log.debug("cipherText:" + cipherText);
				        	
				        	ReflectUtil.setFieldValue(args[i], f.getName(), cipherText);
						}
					}

				} catch (Throwable ex) {
					log.error(ex);
				}
			}
		}
	}
	

	private void restoreObject(Object[] changeArgs, Object[] copyArgs) throws Exception {
		if(changeArgs.length != copyArgs.length ) {
			throw new IllegalArgumentException("changeArgs does not match copyArgs");
		}
		
		for(int i=0; i<changeArgs.length; i++) {
			Object changeArgObj = changeArgs[i];
			
			if(changeArgObj != null) {
				Class<? extends Object> changeArgClass = changeArgObj.getClass();
			
				try {
					for (Field changeArgfield : changeArgClass.getDeclaredFields()) {
						if (changeArgfield.isAnnotationPresent(Encrypt.class) && changeArgfield.getType().getName().equalsIgnoreCase("java.lang.String")) {
				        	String clearText = (String) ReflectUtil.getFieldValue(copyArgs[i], changeArgfield.getName());
							
log.debug("restoreClearText:" + clearText);
				        	
				        	ReflectUtil.setFieldValue(changeArgs[i], changeArgfield.getName(), clearText);
						}
					}

				} catch (Throwable ex) {
					log.error(ex);
				}
			}
		}

	}

	private void decryptObject(Object result) {
		for (Field f : result.getClass().getDeclaredFields()) {
			if (f.isAnnotationPresent(Encrypt.class) && f.getType().getName().equalsIgnoreCase("java.lang.String")) {
		        try {
		        	log.debug("encryptBeforeSaving...@Encrypt annotation field name: " + f.getName());

		        	String getMethodName = "get" + Character.toUpperCase(f.getName().charAt(0)) + f.getName().substring(1);
		        	String setMethodName = "set" + Character.toUpperCase(f.getName().charAt(0)) + f.getName().substring(1);
		        	log.debug("decryptAfterFinding...getMethodName: " + getMethodName);
		        	log.debug("decryptAfterFinding...setMethodName: " + setMethodName);
		        	
		        	Object[] parms = null;
		        	Method gm = f.getDeclaringClass().getMethod(getMethodName);
		        	String cipherText = (String)gm.invoke(result, parms);
		        	log.debug("decryptAfterFinding...getMethodName value: " + cipherText);
		        	
					String decryptedText = SecurityUtil.decrypt(cipherText);
log.debug("decryptedText:" + decryptedText);
					
//    		        String decryptedText = SecureCreditUtils.decrypt(encryptionKeys, cipherText);

		        	ReflectUtil.setFieldValue(result, f.getName(), decryptedText);
		        	
		        } 
		        catch (Throwable ex) {
		        	log.debug("decryptAfterFinding...ex:" + ex.getMessage());
		        }
		     }
		}
	}
	
	
/*	
	private boolean isPrimitive(Class<? extends Object> argClass) throws InstantiationException, IllegalAccessException {
		boolean isPrimitive = false;

		if(argClass.isPrimitive()) {
			isPrimitive = true;
		} else if(argClass.getName().equalsIgnoreCase("java.lang.String")) {
			isPrimitive = true;
		} else if(argClass.getSuperclass() == java.lang.Number.class) {
			isPrimitive = true;
		}
	
log.debug("isPrimitive:" + isPrimitive);
		return isPrimitive;
	}
*/
	
	private static <T extends Annotation> T getAnnotation(Class<?> clazz, Class<T> annotationType) {
	    T result = clazz.getAnnotation(annotationType);
	    if (result == null) {
	        Class<?> superclass = clazz.getSuperclass();
	        if (superclass != null) {
	            return getAnnotation(superclass, annotationType);
	        } else {
	            return null;
	        }
	    } else {
	        return result;
	    }
	}
	
	@SuppressWarnings("unused")
	private class EncryptionObjectResult extends AbstractBean {
		private Object[] changeArgs = null;
		private Object[] copyArgs = null;
		
		public EncryptionObjectResult(Object[] changeArgs, Object[] copyArgs) {
			this.changeArgs = changeArgs;
			this.copyArgs = copyArgs;
		}
		
		public Object[] getChangeArgs() {
			return changeArgs;
		}
		public void setChangeArgs(Object[] changeArgs) {
			this.changeArgs = changeArgs;
		}
		public Object[] getCopyArgs() {
			return copyArgs;
		}
		public void setCopyArgs(Object[] copyArgs) {
			this.copyArgs = copyArgs;
		}
		
	}

}
